package com.uniteksolusi.otomill.model;

import com.pi4j.io.i2c.I2CBus;

public class ModelCrusherBuffer extends ArduinoMegaModel {

	//### CONFIGURE ###//
	//JAGUNG 1, JAGUNG 2, AND SBM 1
	transient byte pinRelayCleanerBlower = 24; 
	transient byte pinRelayBucketCleanerOut = 25;

	transient byte pinRelayCrusher = 26;
	transient byte pinRelayBucketCrusherOut = 27;
	
	transient byte pinRelayScrewCrusherOut = 28;


	transient byte pinRelayPneumaticOutJagung1 = 32; //this is a microswitch to stop moving the router at the right output
	transient byte pinRelayPneumaticOutJagung2 = 33;
	transient byte pinRelayPneumaticOutSBM1 = 34;



	//JAGUNG 1
	transient byte pinBufferLevelJagung1[] = {2,3,4};  //3 pins of IR OBSTACLE = low level, half, full

	//JAGUNG 2
	transient byte pinBufferLevelJagung2[] = {6,7,8};

	//SBM 1
	transient byte pinBufferLevelSBM1[] = {10,11,12};

	//SBM 2
	transient byte pinBufferLevelSBM2[] = {14,15,16}; 
	transient byte pinRelayBucketSBM2 = 17;

	//MBM
	transient byte pinBufferLevelMBM[] = {18,19,20};
	transient byte pinRelayBucketMBM = 21;
	
	//GRIT
	transient byte pinBufferLevelGrit[] = {36,37,38};
	transient byte pinRelayBucketGrit = 39;
	
	//KATUL
	transient byte pinBufferLevelKatul[] = {41,42,43};
	transient byte pinRelayBucketKatul = 44;
	
	
	///### END of CONFIGURATION ###///


	//### running variables ###//
	public byte sharedBucketJagungOrSbm = 0;  //0 = jagung, 1 = sbm
	public byte sbmCleanerOnOff = 0; //when SBM, clean or not
	public byte sbmCrusherOnOff = 1; //when SBM, crush or not 

	byte curOutput = -1;  //-1,0,1,2 = undefined, jagung1, jagung2, sbm1

	//fill state for each silo. 0=off, 1=fill, 2=auto
	byte fillStateJagung1 = 2;
	byte fillStateJagung2 = 2;
	byte fillStateSBM1 = 2;
	byte fillStateSBM2 = 2;

	//when to start filling in auto mode. 0 = low level, 1 = half, 2 = full
	public byte fillLevelJagung1 = 0;
	public byte fillLevelJagung2 = 0;
	public byte fillLevelSBM1 = 0;
	public byte fillLevelSBM2 = 0;


	//status json
	boolean isCleanerOn = false;
	boolean isBucketCleanerOutOn = false;
	boolean isCrusherOn = false;
	boolean isBucketCrusherOutOn = false;
	boolean isScrewCrusherOutOn = false;
	
	boolean isInputJagung1Open = false;
	boolean isInputJagung2Open = false;
	boolean isInputSBM1Open = false;
	
	boolean isBucketSBM2On = false;

	public ModelCrusherBuffer(I2CBus bus, int address) {
		super(bus, address);
	}

	@Override
	protected void initialize() {

		//JAGUNG 1, JAGUNG 2, AND SBM 1
		pinMode(pinRelayCleanerBlower, OUTPUT); 
		pinMode(pinRelayBucketCleanerOut, OUTPUT);

		pinMode(pinRelayCrusher, OUTPUT);
		pinMode(pinRelayBucketCrusherOut, OUTPUT);
		pinMode(pinRelayScrewCrusherOut, OUTPUT);
		
		pinMode(pinRelayPneumaticOutJagung1, OUTPUT); 
		pinMode(pinRelayPneumaticOutJagung2, OUTPUT);
		pinMode(pinRelayPneumaticOutSBM1, OUTPUT);


		//JAGUNG 1
		pinMode(pinBufferLevelJagung1[0], INPUT); 	//3 pins of IR OBSTACLE = low level, half, full
		pinMode(pinBufferLevelJagung1[1], INPUT);
		pinMode(pinBufferLevelJagung1[2], INPUT);

		//JAGUNG 2
		pinMode(pinBufferLevelJagung2[0], INPUT); 
		pinMode(pinBufferLevelJagung2[1], INPUT);
		pinMode(pinBufferLevelJagung2[2], INPUT);

		//SBM 1
		pinMode(pinBufferLevelSBM1[0], INPUT);
		pinMode(pinBufferLevelSBM1[1], INPUT);
		pinMode(pinBufferLevelSBM1[2], INPUT); 

		//SBM 2
		pinMode(pinBufferLevelSBM2[0], INPUT);
		pinMode(pinBufferLevelSBM2[1], INPUT);
		pinMode(pinBufferLevelSBM2[2], INPUT);	

		pinMode(pinRelayBucketSBM2, OUTPUT);

	}

	@Override
	protected void mainLoop() {

		//check and fill each silos


		if(sharedBucketJagungOrSbm == 0) { //jagung

			if(curOutput == 0) { //jagung1  
				
				moveCrusherOutToJagung1();

				if(fillStateJagung1 == 2) {
					
					if(isJagung1Full()) {
						//turnOffCleanerCrusherLine(); TODO needed?
						if(fillStateJagung2==2 && !isJagung2Full()) {
						
							moveCrusherOutToJagung2();
						
						} else { //both are full
							
							turnOffCleanerCrusherLine();
						
						}
						
					} else if(isJagung1ToFill()) {
						turnOnCleanerCrusherLine();
					}
					
				} else if(fillStateJagung1 == 1) {

					turnOnCleanerCrusherLine(); //lower than fill level, start the bucket

				} else if(fillStateJagung1 == 0) { //off

					turnOffCleanerCrusherLine();

				}

			} if(curOutput == 1) { //jagung2  
				
				moveCrusherOutToJagung2();

				if(fillStateJagung2 == 2) {

					if(isJagung2Full()) {
						//turnOffCleanerCrusherLine(); TODO needed?
						if(fillStateJagung1==2 && !isJagung1Full()) {
							
							moveCrusherOutToJagung1();
					
						} else { //both are full
						
							turnOffCleanerCrusherLine();
						
						}
						
					} else if(isJagung2ToFill()) {
						turnOnCleanerCrusherLine();
					}

				} else if(fillStateJagung2 == 1) {

					turnOnCleanerCrusherLine(); //lower than fill level, start the bucket

				} else if(fillStateJagung2 == 0) { //off

					turnOffCleanerCrusherLine();

				}

			} else { //setting is set for jagung, but crusher out not yet set for jagung

				//let's start with jagung1
				moveCrusherOutToJagung1();

			}


		} else if(sharedBucketJagungOrSbm == 1) { //sbm1

			//sbm 1
			if(curOutput == 2) { //sbm1
				
				moveCrusherOutToSBM1();
				
				if(fillStateSBM1 == 2) {
					
					if(isSBM1Full()) {
						turnOffCleanerCrusherLine();
					} else if(isSBM1ToFill()) {
						turnOnCleanerCrusherLine();
					}
					
				} //else, it means, it is filling already passed fill level, but not yet full, just do nothing and continue
				
				else if(fillStateSBM1 == 0) { //stop filling

					turnOffCleanerCrusherLine();					

				} else if(fillStateSBM1 == 1) { //start filling

					turnOnCleanerCrusherLine();

				}

			} else { //setting is set for SBM1, but crusher out not yet set for SBM1

				moveCrusherOutToSBM1();

			}

		}



		//sbm 2
		if(fillStateSBM2 == 2) { //0=off, 1=on, 2=auto
			if(isSBM2Full()) { //level 2 = full, IR obstacle read 0 = there is obstacle
				digitalWrite(pinRelayBucketSBM2, LOW); //full, stop the bucket
			} else if(isSBM2ToFill()) { //IR read 1 = no obstacle at the fillLevel
				digitalWrite(pinRelayBucketSBM2, HIGH); //lower than fill level, start the bucket
			} //else, it means, it is filling already passed fill level, but not yet full, just do nothing and continue
		} else if(fillStateSBM2 == 0) { //off
			digitalWrite(pinRelayBucketSBM2, LOW); //stop the bucket
		} else if(fillStateSBM2 == 1) {
			digitalWrite(pinRelayBucketSBM2, HIGH); //start the bucket
		}

	}
	
	
	private boolean isJagung1Full() {
		return (digitalRead(pinBufferLevelJagung1[2]) == LOW);
	}
	
	private boolean isJagung2Full() {
		return (digitalRead(pinBufferLevelJagung2[2]) == LOW);
	}
	
	private boolean isSBM1Full() {
		return (digitalRead(pinBufferLevelSBM1[2]) == LOW);
	}
	
	private boolean isSBM2Full() {
		return (digitalRead(pinBufferLevelSBM2[2]) == LOW);
	}
	
	
	private boolean isJagung1ToFill() {
		return (digitalRead(pinBufferLevelJagung1[fillLevelJagung1]) == HIGH);
	}
	
	private boolean isJagung2ToFill() {
		return (digitalRead(pinBufferLevelJagung2[fillLevelJagung2]) == HIGH);
	}
	
	private boolean isSBM1ToFill() {
		return (digitalRead(pinBufferLevelSBM1[fillLevelSBM1]) == HIGH);
	}
	
	private boolean isSBM2ToFill() {
		return (digitalRead(pinBufferLevelSBM2[fillLevelSBM2]) == HIGH);
	}


	void turnOnCleanerCrusherLine(){

		digitalWrite(pinRelayScrewCrusherOut, HIGH);
		
		digitalWrite(pinRelayBucketCrusherOut, HIGH); 

		if(sharedBucketJagungOrSbm == 1 && sbmCrusherOnOff == 0) { //this is SBM with crusher setting is off
			digitalWrite(pinRelayCrusher, LOW); 
		} else { //this is jagung (always with crusher) OR SBM with crusher setting on 
			digitalWrite(pinRelayCrusher, HIGH); 
		}

		digitalWrite(pinRelayBucketCleanerOut, HIGH);

		if(sharedBucketJagungOrSbm == 1 && sbmCleanerOnOff == 0) { //this is SBM with cleaner setting is off
			digitalWrite(pinRelayCleanerBlower, LOW); 
		} else { //this is jagung (always with cleaner) OR SBM with cleaner setting on 
			digitalWrite(pinRelayCleanerBlower, HIGH); 
		}

	}


	void moveCrusherOutToJagung1() {

		curOutput = 0;
		digitalWrite(pinRelayPneumaticOutJagung1, HIGH);
		digitalWrite(pinRelayPneumaticOutJagung2, LOW);
		digitalWrite(pinRelayPneumaticOutSBM1, LOW);

	}


	void moveCrusherOutToJagung2() {

		curOutput = 1;
		digitalWrite(pinRelayPneumaticOutJagung1, LOW);
		digitalWrite(pinRelayPneumaticOutJagung2, HIGH);
		digitalWrite(pinRelayPneumaticOutSBM1, LOW);

	}


	void moveCrusherOutToSBM1() {

		curOutput = 2;
		digitalWrite(pinRelayPneumaticOutJagung1, LOW);
		digitalWrite(pinRelayPneumaticOutJagung2, LOW);
		digitalWrite(pinRelayPneumaticOutSBM1, HIGH);
		
	}



	void turnOffCleanerCrusherLine() {	
		digitalWrite(pinRelayCleanerBlower, LOW); 
		digitalWrite(pinRelayBucketCleanerOut, LOW); 
		digitalWrite(pinRelayCrusher, LOW); 
		digitalWrite(pinRelayBucketCrusherOut, LOW);
	}


	protected void writeRequestByteSpecific(byte[] requestByte) {
		//nothing special
	}

	protected void readResponseByteSpecific(byte[] responseByte) {
		//nothing special
	}
	
	
	void digitalWrite(byte pinNumber, byte highLow) {
		
		super.digitalWrite(pinNumber, highLow);
		
		if(highLow == LOW) {
			
			if(pinNumber == pinRelayCleanerBlower) {
				isCleanerOn = false;
			} else if(pinNumber == pinRelayBucketCleanerOut) {
				isBucketCleanerOutOn = false;
			} else if(pinNumber == pinRelayCrusher) {
				isCrusherOn = false;
			} else if(pinNumber == pinRelayBucketCrusherOut) {
				this.isBucketCrusherOutOn = false;
			} else if(pinNumber == pinRelayScrewCrusherOut) {
				isScrewCrusherOutOn = false;
			} else if(pinNumber == pinRelayPneumaticOutJagung1) {
				isInputJagung1Open = false;
			} else if(pinNumber == pinRelayPneumaticOutJagung2) {
				isInputJagung2Open = false;
			} else if(pinNumber == pinRelayPneumaticOutSBM1) {
				isInputSBM1Open = false;
			} else if(pinNumber == pinRelayBucketSBM2) {
				isBucketSBM2On = false;
			} 
			
		} else if(highLow == HIGH) {
			
			if(pinNumber == pinRelayCleanerBlower) {
				isCleanerOn = true;
			} else if(pinNumber == pinRelayBucketCleanerOut) {
				isBucketCleanerOutOn = true;
			} else if(pinNumber == pinRelayCrusher) {
				isCrusherOn = true;
			} else if(pinNumber == pinRelayBucketCrusherOut) {
				this.isBucketCrusherOutOn = true;
			} else if(pinNumber == pinRelayScrewCrusherOut) {
				isScrewCrusherOutOn = true;
			} else if(pinNumber == pinRelayPneumaticOutJagung1) {
				isInputJagung1Open = true;
			} else if(pinNumber == pinRelayPneumaticOutJagung2) {
				isInputJagung2Open = true;
			} else if(pinNumber == pinRelayPneumaticOutSBM1) {
				isInputSBM1Open = true;
			} else if(pinNumber == pinRelayBucketSBM2) {
				isBucketSBM2On = true;
			} 
			
		} 
		
		
	}


	public String printStateDetails() {
		
		StringBuffer sb  = new StringBuffer(super.printStateDetails());

		sb.append("\n");
		sb.append("\nJagung/SBM:\t " + this.sharedBucketJagungOrSbm);
		sb.append(" . . . . . ||| Cur Output Jagung1/Jagung2/SBM1 :\t. " + curOutput);
		
		sb.append("\n");
		sb.append("\nSBM Cleaner/Crusher Conf :\t " + this.sbmCleanerOnOff + " / " + this.sbmCrusherOnOff);
		sb.append("\nCleaner/OutBucket Status :\t " + digitalRead(pinRelayCleanerBlower) + " / " + digitalRead(pinRelayBucketCleanerOut));
		sb.append(" || Crusher/OutBucket/Screw Status :\t " + digitalRead(pinRelayCrusher) + " / " + digitalRead(pinRelayBucketCrusherOut) + " / " + digitalRead(pinRelayScrewCrusherOut));
		
		sb.append("\n");
		String tempString = "STOP";
		if(curOutput==0 && digitalRead(pinRelayCrusher)==HIGH){
			tempString = "FILL";
		}
		sb.append("\nJagung1 State:\t " + tempString);
		
		tempString = "STOP";
		if(curOutput==1 && digitalRead(pinRelayCrusher)==HIGH){
			tempString = "FILL";
		}
		sb.append(" | Jagung1 State:\t " + tempString);
		
		tempString = "STOP";
		if(curOutput==2 && digitalRead(pinRelayCrusher)==HIGH){
			tempString = "FILL";
		}
		sb.append(" | SBM1 State:\t " + tempString);
		
		
		sb.append("\nJagung1 Level:\t " + digitalRead(this.pinBufferLevelJagung1[0]) +""+ digitalRead(this.pinBufferLevelJagung1[1]) +""+ digitalRead(this.pinBufferLevelJagung1[2])); 
		sb.append(" || Jagung2 Level:\t " + digitalRead(this.pinBufferLevelJagung2[0]) +""+ digitalRead(this.pinBufferLevelJagung2[1]) +""+ digitalRead(this.pinBufferLevelJagung2[2])); 
		sb.append(" || SBM1 Level:\t " + digitalRead(this.pinBufferLevelSBM1[0]) +""+ digitalRead(this.pinBufferLevelSBM1[1]) +""+ digitalRead(this.pinBufferLevelSBM1[2])); 
		
		sb.append("\n");
		tempString = "STOP";
		if(digitalRead(pinRelayBucketSBM2)==HIGH){
			tempString = "FILL";
		}
		sb.append("\nSBM2 Fill State:\t " + tempString + " (Conf: " + fillLevelSBM2 + ")");
		sb.append("\nSBM2 Level . . :\t " + digitalRead(this.pinBufferLevelSBM2[0]) +""+ digitalRead(this.pinBufferLevelSBM2[1]) +""+ digitalRead(this.pinBufferLevelSBM2[2]));
		
		return sb.toString();
	
	}	
	
	
	public String processCommand(String stringCommand) {
		
		String[] cmds = stringCommand.trim().split(" ");
		
		if(cmds.length > 0) {
		
			if("setJagung".equals(cmds[0])) {
				sharedBucketJagungOrSbm=0;
				moveCrusherOutToJagung1();
				return "OK";
			}
			
			if("setSBM".equals(cmds[0])) {
				sharedBucketJagungOrSbm=1;
				moveCrusherOutToSBM1();
				return "OK"; 
			}
			
			if("startSBMCrusher".equals(cmds[0])) {
				this.sbmCrusherOnOff=1;
				return "OK"; 
			}
			
			if("stopSBMCrusher".equals(cmds[0])) {
				this.sbmCrusherOnOff=0;
				return "OK"; 
			}
			
		}
		
		String parentResponse = super.processCommand(stringCommand);
		if(parentResponse.startsWith("NOK")) {
			parentResponse = parentResponse 
								+ "Available commands "+this.getClass().getSimpleName()
								+": setJagung, setSBM, startSBMCrusher, stopSBMCrusher\n";
		}
		return parentResponse;
	}

}
